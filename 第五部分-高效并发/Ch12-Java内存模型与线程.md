# 第12章 Java内存模型与线程

## 12.2 硬件的效率与一致性
- 基于高速缓存的存储交互很好地解决了处理器与内存速度之间的矛盾，但是也为计算机系统带来更高的复杂度，它引入一个新的问题：
缓存一致性（Cache Coherence）。在多路处理系统中，每个处理器都有自己的高速缓存，而它们又共享同一主内存（Main Memory），
这种系统称为共享内存多核系统（Shared Memory Multiprocessors System）。当多个处理器的运算任务都涉及同一块主内存区域时，
将可能导致各自的缓存数据不一致。如果真的发生这种情况，那同步回到主内存该以谁的缓存数据为准呢？为了解决一致性的问题，
需要各个处理器访问缓存时都遵循一些协议，在读写时要根据协议来进行操作，这类协议有MSI，MESI（Illinois Protocol）、MOSI、
Synapse、Firefly及Dragon Protocol等。从本章开始，我们将会频繁见到"内存模型"一词，它可以理解为在特定的操作协议下，
对特定的内存或高速缓存进行读写访问的过程抽象。不同架构的物理机器可以拥有不一样的内存模型，而Java虚拟机也有自己的内存模型，
并且与这里介绍的内存访问操作及硬件的缓存访问操作具有高度的可类比性。
- 处理增加高速缓存之外，为了使处理器内部的运算单元尽量被充分利用，处理器可能会输入代码进行乱序执行（Out-Of-Order Execution）优化，
处理器会在计算之后将乱序执行的结果重组，保证该结果与顺序执行的结果是一致的，但并不保证程序中各个语句计算的先后顺序与输入代码中的顺序一致，
因此如果存在一个计算任务依赖另一个计算任务的中间结果，那么其顺序性并不能靠代码的先后顺序来保证。与处理器的乱序执行优化类似，
Java虚拟机的即时编译器中也有指令重排序（Instruction Reorder）优化。

## 12.3 Java内存模型

### 12.3.1 主内存与工作内存
- Java内存模型的主要目的是定义程序中各种变量的访问规则，即关注在虚拟机中把变量值存储到内存和从内存中去除变量值这样的底层细节。
为了获取更好的执行效能，Java内存模型并没有限制执行引擎使用处理器的特定寄存器或缓存来和主内存进行交互，也没有限制即时编译器是否要进行调整代码执行这类优化措施。
- Java内存模型规定了所有的变量都存储在主内存（Main Memory）中。每条线程还有自己的工作内存（Working Memory，可与前面讲的高速缓存类比），
线程的工作内存中保存了被该线程使用的变量的主内存副本，线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，
而不能直接读写内存中的数据。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成，
线程、主内存、工作内存三者的交互关系如图12-2所示。

### 12.3.2 内存间交互操作
- 关于主内存与工作内存之间具体的交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步回主内存这一类的实现细节，
Java内存模型中定义了以外8种操作来完成。Java虚拟机实现时必须保证下面提及的每一种操作都是原子的、不可再分的（对于double和long类型的变量来说，
load、store、read和write操作在某些平台上允许有例外，这个问题在12.3.4节会专门讨论）。
  - load（锁定）：作用于主内存的变量，它把一个变量标识为一条线程独占的状态。
  - unlock（解锁）：作用于主内存的变量，它吧一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。
  - read（读取）：作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，一遍随后的load动作使用。
  - load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。
  - use（使用）：作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。
  - assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接受的值赋给工作内存的变量，每当虚拟机遇到一个变量赋值的字节码指令时执行这个操作。
  - store（存储）：作用于工作内存中的变量，它把工作内存中一个变量的值传送到主内存中，以便随后的write操作使用。
  - write（写入）：作用于主内存中，它把store操作从工作内存中得到的变量的值放入主内存的变量中。